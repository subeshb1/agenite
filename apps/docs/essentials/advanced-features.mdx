---
title: "Advanced features"
description: "Explore Agenite's powerful advanced capabilities"
---

## Custom tools

Create sophisticated tools with advanced features:

### Schema validation

Use JSON Schema for complex input validation:

```typescript
const weatherTool = new Tool<WeatherInput>({
  name: 'weather',
  description: 'Get weather information',
  version: '1.0.0',
  inputSchema: {
    type: 'object',
    properties: {
      location: {
        type: 'object',
        properties: {
          city: { type: 'string' },
          country: { type: 'string' },
          coordinates: {
            type: 'object',
            properties: {
              lat: { type: 'number' },
              lon: { type: 'number' },
            },
            required: ['lat', 'lon'],
          },
        },
        required: ['city'],
      },
      units: {
        type: 'string',
        enum: ['metric', 'imperial'],
        default: 'metric',
      },
    },
    required: ['location'],
  },
  execute: async ({ input }) => {
    // Tool implementation
  },
});
```

### API integration

Wrap external APIs with proper error handling:

```typescript
const createApiTool = (apiKey: string) => {
  const client = new ApiClient(apiKey);

  return new Tool({
    // ... tool configuration
    execute: async ({ input }) => {
      try {
        const response = await client.request(input);
        return {
          isError: false,
          data: response,
        };
      } catch (error) {
        if (error.status === 429) {
          return {
            isError: true,
            data: 'Rate limit exceeded',
            error: {
              code: 'RATE_LIMIT',
              message: 'Please try again later',
              retryAfter: error.headers['retry-after'],
            },
          };
        }
        // Handle other errors
      }
    },
  });
};
```

## Custom middleware

Create middleware for advanced use cases:

### Rate limiting

```typescript
const rateLimitMiddleware = (
  limit: number,
  window: number
): AsyncGeneratorMiddleware => {
  const timestamps: number[] = [];

  return async function* (generator, context) {
    const now = Date.now();
    timestamps.push(now);
    
    // Remove old timestamps
    while (timestamps[0] < now - window) {
      timestamps.shift();
    }

    if (timestamps.length > limit) {
      throw new Error('Rate limit exceeded');
    }

    yield* generator;
  };
};
```

### Logging and monitoring

```typescript
const loggingMiddleware = (
  logger: Logger
): AsyncGeneratorMiddleware => {
  return async function* (generator, context) {
    const startTime = Date.now();
    
    try {
      for await (const value of generator) {
        logger.debug('Step output', {
          type: value.type,
          timestamp: new Date().toISOString(),
        });
        yield value;
      }
    } catch (error) {
      logger.error('Execution error', {
        error,
        duration: Date.now() - startTime,
      });
      throw error;
    }

    logger.info('Execution complete', {
      duration: Date.now() - startTime,
      tokenUsage: context.tokenUsage,
    });
  };
};
```

## Custom state management

Implement complex state management:

### Persistent state

```typescript
interface PersistentState {
  conversations: Map<string, Message[]>;
  metadata: Record<string, unknown>;
}

const createPersistentAgent = (storage: Storage) => {
  return new Agent<PersistentState>({
    // ... agent configuration
    initialState: await storage.load(),
    stateReducer: {
      conversations: async (newValue, prev) => {
        const updated = new Map(prev);
        updated.set(newValue.id, newValue.messages);
        await storage.save({ conversations: updated });
        return updated;
      },
      metadata: async (newValue, prev) => {
        const updated = { ...prev, ...newValue };
        await storage.save({ metadata: updated });
        return updated;
      },
    },
  });
};
```

### State validation

```typescript
const createValidatedReducer = <T>(
  schema: JSONSchema,
  reducer: StateReducer<T>
): StateReducer<T> => {
  const validate = new Ajv().compile(schema);

  return Object.fromEntries(
    Object.entries(reducer).map(([key, fn]) => [
      key,
      (newValue: unknown, prevValue: unknown) => {
        const result = fn(newValue, prevValue);
        if (!validate(result)) {
          throw new Error(
            `Invalid state: ${JSON.stringify(validate.errors)}`
          );
        }
        return result;
      },
    ])
  );
};
```

## Custom execution steps

Create custom execution steps:

### Retry step

```typescript
const createRetryStep = (
  maxRetries: number,
  baseDelay: number
): Step => ({
  beforeExecute: async (context) => {
    return {
      ...context,
      retries: 0,
    };
  },
  execute: async function* (params, context) {
    while (true) {
      try {
        const result = yield* originalStep.execute(params, context);
        return result;
      } catch (error) {
        if (context.retries >= maxRetries) {
          throw error;
        }
        
        const delay = baseDelay * Math.pow(2, context.retries);
        await new Promise(resolve => setTimeout(resolve, delay));
        
        context.retries++;
      }
    }
  },
});
```

### Caching step

```typescript
const createCachingStep = (
  cache: Cache,
  ttl: number
): Step => ({
  execute: async function* (params, context) {
    const cacheKey = computeCacheKey(params);
    const cached = await cache.get(cacheKey);
    
    if (cached) {
      return cached;
    }

    const result = yield* originalStep.execute(params, context);
    await cache.set(cacheKey, result, ttl);
    
    return result;
  },
});
```

## Multi-agent patterns

Implement advanced multi-agent architectures:

### Chain of responsibility

```typescript
const createAgentChain = (agents: Agent[]) => {
  return new Agent({
    name: 'chain',
    execute: async function* (params) {
      let result = params;
      
      for (const agent of agents) {
        result = yield* agent.execute(result);
        
        if (result.final) {
          return result;
        }
      }
      
      return result;
    },
  });
};
```

### Parallel execution

```typescript
const createParallelAgent = (agents: Agent[]) => {
  return new Agent({
    name: 'parallel',
    execute: async function* (params) {
      const results = await Promise.all(
        agents.map(agent => agent.execute(params))
      );
      
      return {
        results,
        summary: await summarizeResults(results),
      };
    },
  });
};
```

## Next steps

- Check out the [examples](/essentials/examples)
- Read the [API reference](/api-reference/agent)
- Join our [community](https://discord.gg/agenite) 
